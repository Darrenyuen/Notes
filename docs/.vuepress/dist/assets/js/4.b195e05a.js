(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{171:function(_,v,i){"use strict";i.r(v);var l=i(0),n=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("div",{staticClass:"content"},[i("h2",{attrs:{id:"数据结构与算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法","aria-hidden":"true"}},[_._v("#")]),_._v(" 数据结构与算法")]),_._v(" "),i("ul",[i("li",[_._v("抽象数据类型\n"),i("ul",[i("li",[_._v("数据类型\n"),i("ul",[i("li",[_._v("数据对象集")]),_._v(" "),i("li",[_._v("数据集合相关联的操作集")])])]),_._v(" "),i("li",[_._v("抽象\n"),i("ul",[i("li",[_._v("描述数据类型的方法不依赖具体实现")])])])])]),_._v(" "),i("li",[_._v("算法\n"),i("ul",[i("li",[_._v("输入")]),_._v(" "),i("li",[_._v("输出")]),_._v(" "),i("li",[_._v("确定")]),_._v(" "),i("li",[_._v("可行")]),_._v(" "),i("li",[_._v("有限")])])]),_._v(" "),i("li",[_._v("好的算法（从时间复杂度T(n)和空间复杂度S(n)去考量）\n"),i("ul",[i("li",[_._v("正确")]),_._v(" "),i("li",[_._v("可读")]),_._v(" "),i("li",[_._v("健壮")]),_._v(" "),i("li",[_._v("高效")]),_._v(" "),i("li",[_._v("低存储")])])])]),_._v(" "),i("h4",{attrs:{id:"线性表"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#线性表","aria-hidden":"true"}},[_._v("#")]),_._v(" 线性表")]),_._v(" "),i("p",[_._v("熟悉各类线性表的结构及基本操作：")]),_._v(" "),i("ol",[i("li",[_._v("初始化")]),_._v(" "),i("li",[_._v("销毁")]),_._v(" "),i("li",[_._v("清空")]),_._v(" "),i("li",[_._v("判断是否为空")]),_._v(" "),i("li",[_._v("求长度")]),_._v(" "),i("li",[_._v("查找第几个元素")]),_._v(" "),i("li",[_._v("查找某元素的位置")]),_._v(" "),i("li",[_._v("直接前驱")]),_._v(" "),i("li",[_._v("直接后继")]),_._v(" "),i("li",[_._v("插入")]),_._v(" "),i("li",[_._v("删除")])]),_._v(" "),i("ul",[i("li",[_._v("线性表的顺序表示和实现——数组\n"),i("ul",[i("li",[_._v("静态分配的顺序表存储")]),_._v(" "),i("li",[_._v("动态分配的顺序表存储")])])]),_._v(" "),i("li",[_._v("线性表的链式表示和实现——链表\n"),i("ul",[i("li",[_._v("单链表\n"),i("ul",[i("li",[_._v("不带头节点")]),_._v(" "),i("li",[_._v("带头节点")])])]),_._v(" "),i("li",[i("em",[_._v("静态链表")])]),_._v(" "),i("li",[_._v("双向循环链表\n##栈和队列\n栈、队列算受限的线性表")])])])]),_._v(" "),i("h4",{attrs:{id:"栈（stack）"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#栈（stack）","aria-hidden":"true"}},[_._v("#")]),_._v(" 栈（stack）")]),_._v(" "),i("ul",[i("li",[_._v("特点：后进先出")])]),_._v(" "),i("p",[_._v("栈的主要操作：\n1. 进栈\n2. 出栈\n3. 取栈顶\n4. 初始化空栈\n5. 判栈空否\n6. 判栈满否")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("动态顺序栈")])]),_._v(" "),i("li",[i("p",[_._v("静态顺序栈")])]),_._v(" "),i("li",[i("p",[_._v("链式栈")])])]),_._v(" "),i("h4",{attrs:{id:"队列（queue）"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#队列（queue）","aria-hidden":"true"}},[_._v("#")]),_._v(" 队列（queue）")]),_._v(" "),i("ul",[i("li",[_._v("特点：先进先出")])]),_._v(" "),i("p",[_._v("队列的主要操作：\n1. 初始化\n2. 队空\n3. 取对头元素\n4. 入队\n5. 出队")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("链队列")])]),_._v(" "),i("li",[i("p",[_._v("循环队列：通过取模实现")])])]),_._v(" "),i("ol",[i("li",[_._v("队头、队尾指针加1，用取模(余数)运算实现循环")]),_._v(" "),i("li",[_._v("队头指针加1:  front = (front+1) %maxsize;")]),_._v(" "),i("li",[_._v("队尾指针加1:  rear = (rear+1) % maxsize;")]),_._v(" "),i("li",[_._v("队列初始化：front = rear = 0;")]),_._v(" "),i("li",[_._v("队空条件：front == rear;")]),_._v(" "),i("li",[_._v("队满条件：(rear+1) % maxsize == front;")])]),_._v(" "),i("h4",{attrs:{id:"数组"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#数组","aria-hidden":"true"}},[_._v("#")]),_._v(" 数组")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("数组的定义")])]),_._v(" "),i("li",[i("p",[_._v("数组的顺序表示和实现（行优先、列优先）")])]),_._v(" "),i("li",[i("p",[_._v("矩阵的运算")])]),_._v(" "),i("li",[i("p",[_._v("矩阵的压缩存储")]),_._v(" "),i("ol",[i("li",[_._v("指为多值相同的元素只分配一个存储空间")]),_._v(" "),i("li",[_._v("对零元素不分配空间")])])]),_._v(" "),i("li",[i("p",[_._v("特殊矩阵")]),_._v(" "),i("ul",[i("li",[_._v("对称矩阵（n^2个元素压缩存储到n(n+1)/2）个元的空间中")]),_._v(" "),i("li",[_._v("三角矩阵")]),_._v(" "),i("li",[_._v("对角矩阵")]),_._v(" "),i("li",[_._v("各种矩阵取值操作算法的实现")])])]),_._v(" "),i("li",[i("p",[_._v("稀疏矩阵：只存储行列维数和非零元的行列下标及值")]),_._v(" "),i("ul",[i("li",[_._v("三元组表")]),_._v(" "),i("li",[_._v("十字链表\n####广义表\n广义表的结构特点：")])]),_._v(" "),i("ol",[i("li",[_._v("数据元素有相对次序")]),_._v(" "),i("li",[_._v("长度定义为最外层包含的元素个数")]),_._v(" "),i("li",[_._v("深度定义为所含括弧的重数")]),_._v(" "),i("li",[_._v("广义表可以共享")]),_._v(" "),i("li",[_._v("广义表可以是一个递归的表，递归表的深度是无穷值，长度是有限值")]),_._v(" "),i("li",[_._v("任何一个非空广义表均可分为表头、表尾")])])]),_._v(" "),i("li",[i("p",[_._v("广义表的结构实现以及基本操作")])])]),_._v(" "),i("h4",{attrs:{id:"树"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#树","aria-hidden":"true"}},[_._v("#")]),_._v(" 树")]),_._v(" "),i("p",[_._v("树的定义：")]),_._v(" "),i("h4",{attrs:{id:"树与二叉树"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#树与二叉树","aria-hidden":"true"}},[_._v("#")]),_._v(" 树与二叉树")]),_._v(" "),i("p",[_._v("树转换为二叉树：子节点当作左子树，兄弟节点当作右子树")]),_._v(" "),i("ul",[i("li",[_._v("二叉树的存储结构\n"),i("ul",[i("li",[_._v("顺序存储")]),_._v(" "),i("li",[_._v("链式存储（二叉链表、三叉链表（可以通过静态结构来实现））")])])]),_._v(" "),i("li",[_._v("二叉树的遍历\n"),i("ul",[i("li",[_._v("前序")]),_._v(" "),i("li",[_._v("中序")]),_._v(" "),i("li",[_._v("后序")])])]),_._v(" "),i("li",[_._v("计算二叉树结点个数（递归算法）")]),_._v(" "),i("li",[_._v("计算二叉树中叶子结点的个数（递归算法）")]),_._v(" "),i("li",[_._v("求二叉树的高度（递归算法）")]),_._v(" "),i("li",[_._v("复制二叉树（递归算法）")]),_._v(" "),i("li",[_._v("判断二叉树等价")]),_._v(" "),i("li",[_._v("线索二叉树（Threaded Binary Tree）\n利用n个结点的n+1个空链域记下遍历时得到的二叉树中各结点之间的次序关系")])]),_._v(" "),i("p",[_._v("如何通过先序遍历建立先序线索化二叉树？\n如何通过中序遍历建立先序线索化二叉树？\n如何遍历线索二叉树？")]),_._v(" "),i("ul",[i("li",[_._v("哈夫曼树（带权路径长度最短的树，最优二叉树）\n"),i("ul",[i("li",[_._v("树的路径长度：从树根到每一个结点的路径长度之和")]),_._v(" "),i("li",[_._v("树的带权路径长度：树中所有带权结点的路径长度之和")])])])]),_._v(" "),i("h4",{attrs:{id:"树与森林"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#树与森林","aria-hidden":"true"}},[_._v("#")]),_._v(" 树与森林")]),_._v(" "),i("ul",[i("li",[_._v("树的各种存储结构\n"),i("ul",[i("li",[_._v("双亲表示法")]),_._v(" "),i("li",[_._v("孩子表示法")]),_._v(" "),i("li",[_._v("孩子—兄弟表示法")])])]),_._v(" "),i("li",[_._v("森林、树、二叉树的转换")]),_._v(" "),i("li",[_._v("树的遍历（先根遍历、后根遍历、按层次遍历）")]),_._v(" "),i("li",[_._v("森林的遍历")]),_._v(" "),i("li",[_._v("二叉树的遍历")])]),_._v(" "),i("h4",{attrs:{id:"哈夫曼树"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#哈夫曼树","aria-hidden":"true"}},[_._v("#")]),_._v(" 哈夫曼树")]),_._v(" "),i("p",[_._v("哈夫曼树（带权路径长度最短的树，最优二叉树）")]),_._v(" "),i("pre",[i("code",[_._v("+ 树的路径长度：从树根到每一个结点的路径长度之和\n+ 树的带权路径长度：树中所有带权结点的路径长度之和\n")])]),_._v(" "),i("ul",[i("li",[_._v("采用顺序存储结构——动态分配数组存储")]),_._v(" "),i("li",[_._v("哈夫曼编码（Huffman编码是最优前缀编码，解码时不会混淆）")]),_._v(" "),i("li",[_._v("构造哈夫曼树")]),_._v(" "),i("li",[_._v("构建哈夫曼编码\n##图\n图是由点集和边集构成的，\n有向图的边也叫做弧，弧是顶点的有序对\n无向图\n有向完备图——n个顶点的有向图最大边数是 n(n-1)\n无向完备图——n个顶点的无向图最大边数是n(n-1)/2\n稀疏图：有很少边或弧（）\n稠密图\n顶点的度")]),_._v(" "),i("li",[_._v("无向图中，顶点的度为每个顶点相连的边数")]),_._v(" "),i("li",[_._v("有向图中，顶点的度分为入度和出度")])]),_._v(" "),i("p",[_._v("子图\n权\n网：带权的图\n路径：路径是顶点的序列\n路径长度：沿路径边的数目或沿路径各边权值之和\n回路：第一个顶点和最后一个顶点相同的路径\n简单路径：序列中顶点不重复出现的路径\n简单回路：除了第一和最后一个顶点，其余顶点不重复出现的回路\n连通：两顶点之间有相连的路径，则\n连通图：任意两个顶点都是连通的\n连通分量：非连通图的每一个连通部分（连通的子图）\n强连通图：\n2. 图的抽象数据类型（图的顶点和边分开存储，邻接表和邻接矩阵）\n3. 图的存储结构")]),_._v(" "),i("ul",[i("li",[_._v("dfs,bfs执行一次得到一个连通分量")]),_._v(" "),i("li",[_._v("所有生成树具有以下共同特点：\n"),i("ul",[i("li",[_._v("生成树的顶点个数与图的顶点个数相同")]),_._v(" "),i("li",[_._v("生成树是图的极小连通子图")]),_._v(" "),i("li",[_._v("一个有n个顶点的连通图的生成树有n-1条边")]),_._v(" "),i("li",[_._v("生成树中任意两个顶点间的路径是唯一的")]),_._v(" "),i("li",[_._v("在生成树中再加一条必然形成回路\n矩阵的运算\n压缩矩阵\n十字链表\n递归的三个条件\n树的前中后序遍历")])])])])])}],!1,null,null,null);v.default=n.exports}}]);